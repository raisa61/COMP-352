//pseudo code for the recursive function
Algorithm traverse ( start_row, start_col, board, visited )
{
  Input start_row, start_col, 2D integer array board, 2D boolean array visited
  Output boolean true or false
  
  If(board[start_row][start_col]<--0)
     return true
  else
     Print("Visiting" + start_row + " " + start_col)

     if (visited[start_row][start_col])
        Print("Visited this cell already")
        return false
     
     visited[start_row][start_col]<--true

     int[][] adjacent_cells <-- new int[4][2]
     
     if (start_row - board[start_row][start_col] >= 0) 
	  int[] north <-- {start_row - board[start_row][start_col], start_col}
	  adjacent_cells[0] <-- north
     
     if (start_row + board[start_row][start_col] < board.length) 
	  int[] south <-- {start_row + board[start_row][start_col], start_col}
	  adjacent_cells[1] <-- south
      
     if (start_col + board[start_row][start_col] < board.length) 
	  int[] east <-- {start_row, start_col + board[start_row][start_col]}
	  adjacent_cells[2] <-- east
   
     if (start_col - board[start_row][start_col] >= 0) 
	  int[] west <-- {start_row, start_col - board[start_row][start_col]}
	  adjacent_cells[3] <-- west
			

     for cells<--0 to 4 do
           if (traverse(adjacent_cells[cells][0], adjacent_cells[cells][1],board, visited))
	      return true


  return false

}

//time complexity of the function
?? most probably O(n)

//space complexity of the function
Here, because we are using tail recursion, we don't need to store the previous calls of the functions in the stack anymore, 
as they do not return anything. Therefore, the space complexity will be O(n).





