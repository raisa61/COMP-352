//pseudo code for the recursive function
Algorithm traverse ( start_row, start_col, board, visited )
{
  Input start_row, start_col, 2D integer array board, 2D boolean array visited
  Output boolean true or false
  
  If(board[start_row][start_col]<--0)
     return true
  else
     Print("Visiting" + start_row + " " + start_col)

     if (visited[start_row][start_col])
        Print("Visited this cell already")
        return false
     
     visited[start_row][start_col]<--true

     int[][] adjacent_cells <-- new int[4][2]
     
     if (start_row - board[start_row][start_col] >= 0) 
	  int[] north <-- {start_row - board[start_row][start_col], start_col}
	  adjacent_cells[0] <-- north
     
     if (start_row + board[start_row][start_col] < board.length) 
	  int[] south <-- {start_row + board[start_row][start_col], start_col}
	  adjacent_cells[1] <-- south
      
     if (start_col + board[start_row][start_col] < board.length) 
	  int[] east <-- {start_row, start_col + board[start_row][start_col]}
	  adjacent_cells[2] <-- east
   
     if (start_col - board[start_row][start_col] >= 0) 
	  int[] west <-- {start_row, start_col - board[start_row][start_col]}
	  adjacent_cells[3] <-- west
			

     for cells<--0 to 4 do
           if (traverse(adjacent_cells[cells][0], adjacent_cells[cells][1],board, visited))
	      return true


  return false

}

//time complexity of the function
Here, the time complexity is O(n). Because the worst case scenario is that, we have to traverse through every single cell in the matrix.

//space complexity of the function
Here, because we are using tail recursion, we don't need to store the previous calls of the functions in the stack anymore, 
as they do not return anything. And we are creating arrays inside the method that have constant capacity. Therefore, the space complexity will be O(1).

//Inside the method we are using a boolean 2D array to detect if a cell has already been visited or not. If a cell has been visited, it's set to true, if the same cell is visited again right after a move, it means the traversal will keep looping between these two cells and will never reach the cell containing 0. Thus, we detect it 
as an unsolvable board and return false to prevent stackoverflow error.

//If we used normal recursion, the method will take longer to execute, but since we're using tail recursion, the method recursive gets called only once instead of 4 times 
for 4 different directions. Therefore, this tail recursion version is the fastest version.

