//pseudo code for the recursive function
Algorithm traverse ( start_row, start_col, board, visited )
{
  Input start_row, start_col, 2D integer array board, 2D boolean array visited
  Output boolean true or false
  
  If(board[start_row][start_col]<--0)
     return true
  else
     Print("Visiting" + start_row + " " + start_col)

     if (visited[start_row][start_col])
        Print("Visited this cell already")
        return false
     
     visited[start_row][start_col]<--true

     int[][] adjacent_cells <-- new int[4][2]
     
     if (start_row - board[start_row][start_col] >= 0) 
	  int[] north <-- {start_row - board[start_row][start_col], start_col}
	  adjacent_cells[0] <-- north
     
     if (start_row + board[start_row][start_col] < board.length) 
	  int[] south <-- {start_row + board[start_row][start_col], start_col}
	  adjacent_cells[1] <-- south
      
     if (start_col + board[start_row][start_col] < board.length) 
	  int[] east <-- {start_row, start_col + board[start_row][start_col]}
	  adjacent_cells[2] <-- east
   
     if (start_col - board[start_row][start_col] >= 0) 
	  int[] west <-- {start_row, start_col - board[start_row][start_col]}
	  adjacent_cells[3] <-- west
			

     for cells<--0 to 4 do
           if (traverse(adjacent_cells[cells][0], adjacent_cells[cells][1],board, visited))
	      return true


  return false

}

//time complexity of the function
Here, the time complexity is O(n). Because the worst case scenario is that, we have to traverse through every single cell in the matrix.

//space complexity of the function
Here, because we are using tail recursion, we don't need to store the previous calls of the functions in the stack anymore, 
as they do not return anything. And we are creating arrays inside the method that have constant capacity. Therefore, the space complexity will be O(1).





