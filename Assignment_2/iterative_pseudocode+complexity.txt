//pseudo code for the iterative function
Algorithm traverse ( start_row, start_col, board)
{
  Input start_row, start_col, 2D integer array board
  Output boolean true or false
  
  STACK options(Integer)
  ARRAY visited(Boolean)
  INTEGER current_point <- i*board.length+j
  options.add(current_point)
        while(!options.isEmpty()){
            current_point <- options.pop()
            i <- current_point/board.length
            j <- current_point%board.length
            IF(!visited[current_point]){
                INTEGER step <- board[i][j]
                INTEGER new_i <- i
                INTEGER new_j <- j
                INTEGER new_val <- current_point
                IF(i-step >= 0){
                    new_i -= step
                    new_val <- new_i*board.length+new_j
                    IF(board[new_i][new_j]!=0 AND !visited[new_val]) options.add(new_val) 
                    else IF(board[new_i][new_j]==0) return true
                    new_i<-i
                }
                IF(i+step < board.length){
                    new_i += step
                    new_val = new_i*board.length+new_j
                    IF(board[new_i][new_j]!=0 AND !visited[new_val]) options.add(new_val)
                    else IF(board[new_i][new_j]==0) return true
                    new_i=i
                }
                IF(j-step >= 0){
                    new_j -= step
                    new_val = new_i*board.length+new_j
                    IF(board[new_i][new_j]!=0 AND !visited[new_val]) options.add(new_val)
                    ELSE IF(board[new_i][new_j]==0) return true
                    new_j<-j
                }
                IF(j+step < board.length){
                    new_j += step
                    new_val <- new_i*board.length+new_j
                    IF(board[new_i][new_j]!=0 AND !visited[new_val]) options.add(new_val)
                    ELSE IF(board[new_i][new_j]==0) return true
                    new_j<-j
                }
                
                visited[current_point] <- true
            }
        }
        return false



}

//time complexity of the function
//O(n^4) because worst case we're checking 4 possibilities for each value on the board

//space complexity of the function
//Stack is both O(1) time for storing(push) and O(1) for retrieving(pop)
//However we have O(N) due to the stack which denotes linear space use, the algorithm space use grows together with respect to the number of values on the board
//2D array uses O(N^2)

//We have chosen a stack over a queue - you can think about it as a dfs tree , generally we use a queue(first in first out) when we want to get things out in order we have put them in however with stack (first in last out) we can get things out in a reverse order and that's what we need in this algorithm
//The time complexity for stack would be O(1) but for queues would be O(n).



